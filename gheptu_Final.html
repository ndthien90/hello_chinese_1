<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tr√≤ ch∆°i Gh√©p ch·ªØ H√°n (Phi√™n B·∫£n ƒê∆°n S·∫Øc)</title>
    <!-- T·∫£i Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* T·∫£i Font Mulish (Ti·∫øng Vi·ªát/Giao di·ªán) v√† Ma Shan Zheng (H√°n t·ª±) */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&family=Ma+Shan+Zheng&family=Mulish:ital,wght@0,200..900;1,200..900&display=swap');
        
        /* C·∫≠p nh·∫≠t m√†u n·ªÅn gi·ªëng 2048 */
        body {
            font-family: 'Mulish', 'Inter', sans-serif; 
            background-color: #faf8ef; /* R·∫•t gi·ªëng n·ªÅn 2048 */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            transition: background-color 0.3s ease;
        }

        /* ƒê·ªãnh ki·ªÉu cho c√°c √¥ ch·ªØ H√°n */
        .hanzi-tile {
            width: 100%;
            padding-top: 100%; /* T·∫°o h√¨nh vu√¥ng */
            position: relative;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            /* X√≥a border v√† shadow m·∫∑c ƒë·ªãnh */
            box-shadow: none; 
            border: none;
            border-radius: 6px; /* Bo g√≥c nh·∫π */
            background-color: #cdc1b4; /* M√†u √¥ tr·ªëng, gi·ªëng 2048 */
        }

        /* L∆∞·ªõi 2048 */
        #hanzi-grid {
             background-color: #bbada0; /* M√†u n·ªÅn l∆∞·ªõi, gi·ªëng 2048 */
             padding: 10px;
             border-radius: 6px;
             /* ƒê·∫£m b·∫£o √¥ ch·ªØ H√°n kh√¥ng c√≥ m√†u n·ªÅn m·∫∑c ƒë·ªãnh, m√† do JS g√°n */
        }
        
        .hanzi-content {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Kaiti', 'SimSun', sans-serif; 
            font-size: 1.5rem; 
            font-weight: 580; /* D√πng font ƒë·∫≠m h∆°n */
            color: #776e65; /* M√†u ch·ªØ t·ªëi m·∫∑c ƒë·ªãnh */
            transition: transform 0.1s;
        }

        /* Responsive: TƒÉng k√≠ch th∆∞·ªõc ch·ªØ H√°n tr√™n m√†n h√¨nh l·ªõn h∆°n (>= 768px) */
        @media (min-width: 768px) {
            .hanzi-content {
                font-size: 3rem; 
            }
        }
        /* Ch·ªØ H√°n l·ªõn trong Modal T·ª´ ƒëi·ªÉn c≈©ng d√πng font H√°n */
        #modal-hanzi {
             font-family: 'Kaiti', 'SimSun', sans-serif; 
             font-weight: 580; /* D√πng font ƒë·∫≠m h∆°n */
        }

       #modal-pinyin{
             font-size: 1.5rem; 
        }
       #modal-vn{
             font-size: 1.2rem; 
        }
       #modal-example{
             font-size: 1.2rem; 
        }

        /* Tr·∫°ng th√°i ƒë∆∞·ª£c ch·ªçn */
        .selected {
            /* V·∫´n d√πng m√†u xanh d∆∞∆°ng ƒë·ªÉ l√†m n·ªïi b·∫≠t √¥ ƒëang ƒë∆∞·ª£c ch·ªçn */
            background-color: #3b82f6 !important; 
            transform: scale(0.95);
            color: #ffffff !important;
            box-shadow: 0 0 10px rgba(59, 130, 246, 0.5);
        }
        /* ƒê·∫£m b·∫£o ch·ªØ H√°n b√™n trong √¥ ƒë√£ ch·ªçn c√≥ m√†u tr·∫Øng */
        .selected .hanzi-content {
            color: #ffffff !important; 
        }

        /* Tr·∫°ng th√°i gh√©p ƒë√∫ng */
        .correct {
            animation: correct-fade 0.5s forwards; 
        }
        @keyframes correct-fade {
            0% { background-color: #34d399; opacity: 1; transform: scale(1); } 
            100% { opacity: 0; transform: scale(0.5); }
        }

        /* Tr·∫°ng th√°i gh√©p sai */
        .wrong {
            animation: wrong-shake 0.5s ease-in-out;
            background-color: #f87171 !important; /* M√†u n·ªÅn √¥ sai (Gi·ªëng m√†u √¥ 2) */
            color: #f9f6f2 !important; 
            //box-shadow: 0 0 15px rgba(255, 0, 0, 0.8);
        }
        @keyframes wrong-shake {
            0%, 100% { transform: translateX(0); }
            20%, 60% { transform: translateX(-5px); }
            40%, 80% { transform: translateX(5px); }
        }

        /* Th√™m CSS cho hi·ªáu ·ª©ng ƒëi·ªÉm bay */
        .flying-score {
            position: fixed;
            z-index: 1000;
            font-size: 1.5rem;
            font-weight: bold;
            color: #00FF00; /* M√†u xanh l√° c√¢y */
            opacity: 1;
            pointer-events: none;
            transition: transform 0.8s ease-out, opacity 0.5s linear 0.5s;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
            will-change: transform, opacity; 
        }


        .main-grid {
            max-width: 500px;
            width: 100%; 
            margin: auto;
        }
        
        /* Modal Backdrop */
        .modal-backdrop {
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(2px);
        }
        
        /* DARK MODE STYLES: Gi·ªØ nguy√™n logic Dark Mode nh∆∞ng m√†u t·ªëi s·∫Ω l√† m√†u t·ªëi ri√™ng c·ªßa 2048 */
        .dark {
            background-color: #333; /* N·ªÅn t·ªëi chung */
        }
        .dark body {
            background-color: #333;
        }

        .dark #game-container {
            background-color: #555; /* gray-800 */
            box-shadow: 0 10px 15px -3px rgba(0,0,0,0.5), 0 4px 6px -2px rgba(0,0,0,0.2);
        }
        
        .dark #hanzi-grid {
             background-color: #444; /* M√†u n·ªÅn l∆∞·ªõi t·ªëi */
        }


        .dark .text-gray-700 { color: #d1d5db; } 
        .dark .text-gray-500 { color: #9ca3af; } 
        .dark .text-gray-600 { color: #d1d5db; } 
        .dark .text-gray-800 { color: #f3f4f6; } 

        .dark .hanzi-tile {
            /* M√†u √¥ tr·ªëng t·ªëi */
            background-color: #666; 
        }
        .dark .hanzi-content {
            color: #f3f4f6; /* ƒê·∫£m b·∫£o m√†u ch·ªØ l√† tr·∫Øng/r·∫•t s√°ng trong Dark Mode */
        }

        .dark #selection-display {
            background-color: #4f46e5; 
            color: #e0e7ff; 
        }
        
        .dark #dictionary-modal div, .dark #gameover-modal div {
            background-color: #555; 
        }

        .dark #dictionary-modal .text-gray-500 { color: #9ca3af; }
        .dark .dark #dictionary-modal .border-t { border-color: #374151; }
        
        /* C·∫¨P NH·∫¨T CSS: ƒê·∫£m b·∫£o hi·ªáu ·ª©ng g·ª£i √Ω ph√π h·ª£p v·ªõi Dark Mode */
        /* HINT PULSE L√Ä L·ªöP CHUNG CHO HI·ªÜU ·ª®NG NH·∫§P NH√ÅY */
        .hanzi-tile.hint-pulse {
             color: #776e65 !important;
        }

        .dark .hanzi-tile.hint-pulse {
             background-color: #b45309 !important; /* M√†u Cam ƒê·∫≠m */
             color: #f3f4f6 !important;
        }
        .dark .hanzi-tile.hint-pulse .hanzi-content {
             color: #f3f4f6 !important;
        }

        #level-progress, #level-info {
            display: none;
        }
        
    </style>
    <!-- Th√™m th∆∞ vi·ªán Confetti -->
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.3/dist/confetti.browser.min.js"></script>
    
    <!-- T·∫£i Firebase SDK -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // B·∫≠t ch·∫ø ƒë·ªô Debug cho Firebase
        setLogLevel('Debug');

        // ƒê·ªãnh nghƒ©a c√°c bi·∫øn to√†n c·ª•c (s·∫Ω ƒë∆∞·ª£c Canvas cung c·∫•p)
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-hanzi-app';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
        // KH·∫ÆC PH·ª§C L·ªñI: initialAuthToken l√† JWT Token (chu·ªói string), kh√¥ng c·∫ßn JSON.parse
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null; 

        let app, db, auth, userId = null;

        // Kh·ªüi t·∫°o Firebase v√† x√°c th·ª±c ng∆∞·ªùi d√πng
        if (firebaseConfig) {
            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);

            window.db = db; // G√°n cho window ƒë·ªÉ JS b√™n d∆∞·ªõi c√≥ th·ªÉ truy c·∫≠p

            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    userId = user.uid;
                    // ƒê√£ b·ªè c·∫≠p nh·∫≠t ID ng∆∞·ªùi d√πng tr√™n giao di·ªán
                    // B·∫Øt ƒë·∫ßu l·∫Øng nghe ƒêi·ªÉm Cao Nh·∫•t sau khi x√°c th·ª±c
                    listenForBestScore();
                } else {
                    // X·ª≠ l√Ω x√°c th·ª±c ban ƒë·∫ßu
                    try {
                        if (initialAuthToken) {
                            // S·ª¨ D·ª§NG CHU·ªñI TOKEN TR·ª∞C TI·∫æP
                            await signInWithCustomToken(auth, initialAuthToken); 
                        } else {
                            await signInAnonymously(auth);
                        }
                    } catch (error) {
                        console.error("L·ªói x√°c th·ª±c Firebase:", error);
                        // V·∫´n ch·∫°y game nh∆∞ng kh√¥ng c√≥ l∆∞u ƒëi·ªÉm
                    }
                }
            });
        } else {
            console.warn("Kh√¥ng t√¨m th·∫•y c·∫•u h√¨nh Firebase. Game s·∫Ω ch·∫°y nh∆∞ng kh√¥ng l∆∞u ƒëi·ªÉm cao.");
        }

        // L·∫Øng nghe ƒêi·ªÉm Cao Nh·∫•t t·ª´ Firestore (D·ªØ li·ªáu c√¥ng khai)
        function listenForBestScore() {
            if (!db) return;
            const docRef = doc(db, "artifacts", appId, "public", "data", "hanzi_match_scores", "best_score");

            onSnapshot(docRef, (doc) => {
                if (doc.exists()) {
                    const score = doc.data().score || 0;
                    window.updateBestScore(score); // C·∫≠p nh·∫≠t Best Score trong logic game
                } else {
                    console.log("Ch∆∞a c√≥ Best Score tr√™n Firestore.");
                }
            }, (error) => {
                console.error("L·ªói khi l·∫Øng nghe Best Score:", error);
            });
        }

        // H√†m l∆∞u ƒêi·ªÉm Cao Nh·∫•t v√†o Firestore
        window.saveBestScore = async (newScore) => {
            if (!db || !userId) return;

            const docRef = doc(db, "artifacts", appId, "public", "data", "hanzi_match_scores", "best_score");
            
            try {
                // Ki·ªÉm tra xem ƒëi·ªÉm hi·ªán t·∫°i c√≥ cao h∆°n ƒëi·ªÉm tr√™n Firestore kh√¥ng
                const docSnap = await getDoc(docRef);
                if (docSnap.exists()) {
                    const currentBest = docSnap.data().score || 0;
                    if (newScore > currentBest) {
                        await setDoc(docRef, { score: newScore, userId: userId, updated: new Date().toISOString() });
                        console.log("ƒê√£ c·∫≠p nh·∫≠t Best Score m·ªõi:", newScore);
                    }
                } else {
                    // L∆∞u l·∫ßn ƒë·∫ßu
                    await setDoc(docRef, { score: newScore, userId: userId, updated: new Date().toISOString() });
                }
            } catch (e) {
                console.error("L·ªói khi l∆∞u Best Score:", e);
            }
        };
    </script>
</head>
<body class="bg-gray-50 antialiased">
    <!-- Th√™m th·∫ª Audio ·∫©n ƒë·ªÉ ph√°t file MP3 -->
    <audio id="audio-player" style="display: none;"></audio>

    <!-- C·∫¨P NH·∫¨T: p-4 rounded-xl shadow-xl (cho desktop) -->
    <!-- px-4 py-6 rounded-none shadow-none (cho mobile, tr√†n vi·ªÅn) -->
    <div id="game-container" class="main-grid bg-white px-4 py-6 rounded-none shadow-none md:p-4 md:rounded-xl md:shadow-xl transition-all duration-300 min-h-screen md:min-h-0">
        
        <!-- Thanh Th√¥ng Tin -->
        <div class="flex justify-between items-center mb-4 text-gray-700">
            <div>
                <!-- Ti√™u ƒë·ªÅ ch√≠nh -->
                <div class="text-xl font-black uppercase tracking-widest text-indigo-700 dark:text-indigo-400 mb-0.5">
                    Gh√©p H√°n t·ª± ÊãºÊ±âÂ≠ó
                </div>
                
                <!-- N√∫t chuy·ªÉn ƒë·ªïi Dark Mode -->
                <button id="dark-mode-toggle" class="mt-1 flex items-center text-xs font-semibold text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300 transition duration-150">
                    <span id="dark-mode-icon" class="mr-1">üåô</span> Ch·∫ø ƒë·ªô
                </button>
            </div>
            
            <div class="text-sm font-semibold uppercase text-right">
                <p>ƒêi·ªÉm: <span id="current-score" class="text-blue-600 text-lg">0</span></p>
                <p class="text-xs text-gray-500">Cao Nh·∫•t: <span id="best-score" class="text-green-600">0</span></p>
            </div>
        </div>
        
        <!-- KHU V·ª∞C TH√äM DROP DOWN CH·ªåN B√ÄI H·ªåC -->
        <div class="mb-4">
            <label for="lesson-select" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1"></label>
            <select id="lesson-select" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md dark:bg-gray-700 dark:border-gray-600 dark:text-white">
                <!-- Th√™m m·ªôt v√†i t√πy ch·ªçn gi·∫£ ƒë·ªãnh. B·∫°n c√≥ th·ªÉ th√™m s·ªë l∆∞·ª£ng b√†i h·ªçc t√πy √Ω ·ªü ƒë√¢y -->
                <option value="1">B√†i 1 ËÄÅÂ∏àÊÇ®Â•ΩÔºÅEm ch√†o th·∫ßy ·∫°!</option> 

            </select>
        </div>
        <!-- K·∫æT TH√öC DROP DOWN -->
        
        <!-- Thanh M·ª•c ti√™u (·∫®n - Ch·ªâ d√πng ƒë·ªÉ th√¥ng b√°o t·ªïng ti·∫øn tr√¨nh) -->
        <p id="total-progress-display" class="text-sm font-bold text-gray-700 mb-2">
            ƒê√£ gh√©p: <span id="matched-count">0</span>/<span id="total-words">0</span> t·ª´
        </p>
        <div id="level-progress">
            <div id="level-bar"></div>
        </div>
        
        <!-- Khu v·ª±c hi·ªÉn th·ªã t·ª´ ƒëang gh√©p -->
        <div id="selection-display" class="min-h-[50px] mb-4 p-2 bg-indigo-50 rounded-lg shadow-inner flex items-center justify-center text-xl font-bold text-indigo-700 transition-all duration-300">
            <!-- Ch·ªØ H√°n ƒëang gh√©p s·∫Ω hi·ªÉn th·ªã ·ªü ƒë√¢y -->
        </div>

        <!-- L∆∞·ªõi Ch∆°i 4x4 -->
        <div id="hanzi-grid" class="grid grid-cols-4 gap-2">
            <!-- C√°c √¥ ch·ªØ H√°n s·∫Ω ƒë∆∞·ª£c render b·∫±ng JS -->
        </div>

        <!-- Th√¥ng b√°o Combo/Level -->
        <div id="message-area" class="h-6 mt-4 text-center font-bold text-lg text-yellow-600">
            <!-- Th√¥ng b√°o combo s·∫Ω hi·ªÉn th·ªã ·ªü ƒë√¢y -->
        </div>

        <!-- Khu ƒêi·ªÅu Khi·ªÉn: S·ª¨ D·ª§NG FLEX B√åNH TH∆Ø·ªúNG cho MOBILE v√† DESKTOP (lu√¥n hi·ªÉn th·ªã ngang) -->
        <div class="flex justify-between gap-2 mt-6"> 
            <button id="restart-btn" class="flex-1 py-3 bg-red-500 hover:bg-red-600 text-white font-bold rounded-xl transition  uppercase text-sm">
                <span class="text-lg">üîÑ</span> Ch∆°i L·∫°i
            </button>
            <button id="hint-btn" class="flex-1 py-3 bg-yellow-500 hover:bg-yellow-600 text-white font-bold rounded-xl transition  uppercase text-sm disabled:opacity-50">
                <span class="text-lg">üí°</span> G·ª£i √ù (<span id="hint-count">30</span>)
            </button>
            <!-- N√∫t Next Level ƒë√£ b·ªã x√≥a, ch·ªâ c√≤n 2 n√∫t ch√≠nh -->
        </div>

    </div>

    <!-- Modal T·ª´ ƒêi·ªÉn / Game Over -->
    <div id="dictionary-modal" class="fixed inset-0 z-50 hidden items-center justify-center modal-backdrop">
        <div class="bg-white p-6 rounded-xl shadow-2xl max-w-sm w-full transition-transform transform scale-95" role="dialog">
            <!-- N√∫t Nghe l·∫°i (Speaker Button) -->
            <div class="flex justify-between items-center mb-3">
                <h3 id="modal-title" class="text-3xl font-bold text-green-600">Ch√≠nh x√°c</h3>
                <button id="speaker-btn" class="text-2xl text-green-600 hover:text-green-700 transition disabled:opacity-50" aria-label="Nghe t·ª´">
                    üîä
                </button>
            </div>
            
            <p id="modal-hanzi" class="text-5xl font-extrabold text-center my-4 text-gray-800"></p>
            <p id="modal-pinyin" class="text-2xl text-center font-mono text-green-600 mb-2"></p>
            <p id="modal-vn" class="text-lg text-center text-gray-600 mb-4"></p>
            <p id="modal-example" class="text-sm italic text-gray-500 border-t pt-2 mt-2">V√≠ d·ª•: <span id="modal-example-text"></span></p>

            <!-- ƒê√£ lo·∫°i b·ªè n√∫t ƒê√≥ng ƒë·ªÉ th·ª±c hi·ªán t·ª± ƒë·ªông ƒë√≥ng -->
        </div>
    </div>
    
    <!-- Game Over / Victory Modal -->
    <div id="gameover-modal" class="fixed inset-0 z-50 hidden items-center justify-center modal-backdrop">
        <div class="bg-white p-8 rounded-xl shadow-2xl max-w-md w-full text-center transition-transform transform scale-95" role="dialog">
            <h3 id="gameover-title" class="text-4xl font-extrabold text-red-600 mb-3">H·∫æT GAME!</h3>
            <p class="text-xl text-gray-700 mb-2">ƒêi·ªÉm cu·ªëi c√πng:</p>
            <p id="final-score" class="text-6xl font-black text-blue-600 mb-4">0</p>
            <p id="best-score-update" class="text-md text-green-700 font-semibold mb-6"></p>

            <button onclick="window.restartGame(); document.getElementById('gameover-modal').classList.add('hidden');" class="w-full py-3 bg-red-500 text-white font-bold rounded-lg hover:bg-red-600 transition shadow-lg">Ch∆°i L·∫°i</button>
        </div>
    </div>

    <script>
        // --- C√ÅC BI·∫æN D·ªÆ LI·ªÜU ƒê√É C·∫¨P NH·∫¨T ---
        let WORD_LIST_RAW = [];         
        let WORD_LIST_WITH_IDS = [];    
        // Bi·∫øn LESSON_AUDIO_TIMESTAMPS ƒë√£ ƒë∆∞·ª£c lo·∫°i b·ªè

        const GRID_SIZE = 4;
        const TOTAL_CELLS = GRID_SIZE * GRID_SIZE;

        // --- Tr·∫°ng Th√°i Game M·ªöI ---
        let gridState = [];             
        let currentScore = 0;
        let bestScore = 0;
        let selectedTiles = [];
        let comboCount = 0;
        let hintCount = 3;               
        let isProcessing = false;
        let currentLesson = '1'; 

        let UNSOLVED_WORDS = [];        
        let AVAILABLE_CHAR_POOL = [];   
        let totalWordsMatched = 0;      
        let currentHanziToSpeak = ''; 

        // --- DOM Elements ---
        const gridElement = document.getElementById('hanzi-grid');
        const scoreElement = document.getElementById('current-score');
        const bestScoreElement = document.getElementById('best-score');
        const selectionDisplay = document.getElementById('selection-display');
        const messageArea = document.getElementById('message-area');
        const hintCountElement = document.getElementById('hint-count');
        const hintBtn = document.getElementById('hint-btn');
        const matchedCountElement = document.getElementById('matched-count');
        const totalWordsElement = document.getElementById('total-words');
        const gameoverTitleElement = document.getElementById('gameover-title');
        const darkModeToggle = document.getElementById('dark-mode-toggle');
        const darkModeIcon = document.getElementById('dark-mode-icon');
        const speakerBtn = document.getElementById('speaker-btn');
        const lessonSelect = document.getElementById('lesson-select');
        const audioPlayer = document.getElementById('audio-player'); 

        // --- MAPPING C·∫§U TR√öC TH∆Ø M·ª§C GI·∫¢ ƒê·ªäNH ---
        const BASE_PATH = 'data_ghephantu/'; 
        
        // --- B·∫£ng M√†u 2048 (ƒê∆°n S·∫Øc) ---
        const LIGHT_TILE_COLOR = { bg: '#f9f6f2', text: '#776e65', lightText: true }; 
        const DARK_TILE_COLOR = { bg: '#a39b95', text: '#f9f4f6', lightText: false }; 
        const EMPTY_TILE_COLOR = { bg: '#cdc1b4', text: '#776e65', lightText: true }; 
        const LIGHT_MODE_HINT_COLOR = '#f2b179'; 
        const LIGHT_MODE_HINT_TEXT_COLOR = '#f9f6f2'; 
        
        // ----------------------------------------------------
        // --- LOGIC PH√ÅT √ÇM (∆ØU TI√äN MP3 T·ª™ FILE RI√äNG L·∫∫, D·ª∞ PH√íNG WEB SPEECH) ---
        // ----------------------------------------------------

        // 1. Ph√°t √¢m b·∫±ng Web Speech API (Gi·ªØ nguy√™n)
        const speakHanzi = (text) => {
            if (!('speechSynthesis' in window)) {
                console.warn('Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ Web Speech API.');
                return;
            }

            if (window.speechSynthesis.speaking) {
                 window.speechSynthesis.cancel();
            }
            
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = 'zh-CN'; 
            
            const voices = window.speechSynthesis.getVoices();
            const chineseVoice = voices.find(voice => voice.lang === 'zh-CN' || voice.lang === 'zh-TW');

            if (chineseVoice) {
                utterance.voice = chineseVoice;
            }

            utterance.rate = 1.2; 
            
            speakerBtn.disabled = true;
            speakerBtn.textContent = '‚ñ∂Ô∏è';
            
            utterance.onend = () => {
                speakerBtn.disabled = false;
                speakerBtn.textContent = 'üîä';
            };
            
            utterance.onerror = (event) => {
                console.error('L·ªói ph√°t √¢m Web Speech:', event.error);
                speakerBtn.disabled = false;
                speakerBtn.textContent = '‚ùå';
            };

            window.speechSynthesis.speak(utterance);
        };

        // 2. H√†m Ph√°t √Çm Ch√≠nh (∆Øu ti√™n MP3 t·ª´ file [T·ª´].mp3)
        const playAudioFromLesson = (lessonNumber, hanziText) => {
            // H·ªßy Web Speech n·∫øu ƒëang n√≥i
            if (window.speechSynthesis.speaking) {
                window.speechSynthesis.cancel();
            }
            // D·ª´ng file MP3 hi·ªán t·∫°i n·∫øu ƒëang ph√°t
            audioPlayer.pause();
            audioPlayer.removeAttribute('src'); 

            // X√¢y d·ª±ng ƒë∆∞·ªùng d·∫´n T·ª™ ƒê∆†N L·∫∫ theo c·∫•u tr√∫c m·ªõi: 
            // /data_flashcard/baiX/mp3/T·ª´.mp3
            const audioPath = `${BASE_PATH}bai${lessonNumber}/mp3/${hanziText}.mp3`;
            
            speakerBtn.disabled = true;
            speakerBtn.textContent = 'ƒêang t·∫£i...';

            // H√†m d·ª± ph√≤ng (Fallback)
            const playFallback = (text, reason) => {
                 //messageArea.textContent = `Ph√°t √¢m: ${reason}. D√πng Web Speech API...`;
                 speakerBtn.textContent = 'üîä';
                 speakHanzi(text); 
            };
            
            // X√≥a h·∫øt event c≈© ƒë·ªÉ tr√°nh tr√πng l·∫∑p
            audioPlayer.onloadedmetadata = null;
            audioPlayer.oncanplaythrough = null;
            audioPlayer.onerror = null;
            audioPlayer.onended = null;

            // S·ª± ki·ªán ch√≠nh: khi metadata ƒë∆∞·ª£c t·∫£i (t·ª©c l√† file h·ª£p l·ªá)
            audioPlayer.onloadedmetadata = () => {
                audioPlayer.currentTime = 0; 
                audioPlayer.play().then(() => {
                    console.log(`ƒêang ph√°t MP3 t·ª´ file: ${hanziText}.mp3`);
                    speakerBtn.textContent = '‚ñ∂Ô∏è';
                }).catch(e => {
                    console.warn(`L·ªói khi c·ªë g·∫Øng ph√°t MP3.`, e);
                    playFallback(hanziText, `L·ªói ph√°t MP3 (${e.message})`);
                });
            };
            
            // X·ª≠ l√Ω l·ªói t·∫£i file (File kh√¥ng t·ªìn t·∫°i, l·ªói 404, v.v.)
            audioPlayer.onerror = () => {
                console.warn(`Kh√¥ng t√¨m th·∫•y file MP3: ${audioPath}. Chuy·ªÉn sang Web Speech.`);
                playFallback(hanziText, 'Kh√¥ng t√¨m th·∫•y file MP3');
            };
            
            // X·ª≠ l√Ω khi k·∫øt th√∫c ph√°t
            audioPlayer.onended = () => {
                speakerBtn.textContent = 'üîä';
                speakerBtn.disabled = false;
            };

            // G√°n src v√† t·∫£i file (vi·ªác n√†y s·∫Ω k√≠ch ho·∫°t 'loadedmetadata' ho·∫∑c 'error')
            audioPlayer.src = audioPath;
            audioPlayer.load();
        };

        // 3. X·ª≠ l√Ω s·ª± ki·ªán khi click n√∫t Speaker
        const handleSpeakerClick = () => {
            // Ch·ªâ c·∫ßn hanziText v√† lessonNumber ƒë·ªÉ x√¢y d·ª±ng ƒë∆∞·ªùng d·∫´n file MP3
            if (currentHanziToSpeak) {
                 playAudioFromLesson(currentLesson, currentHanziToSpeak);
            } else {
                 //messageArea.textContent = 'Kh√¥ng c√≥ t·ª´ n√†o ƒë·ªÉ ph√°t √¢m.';
            }
        };


        // ----------------------------------------------------
        // --- H√ÄM T·∫¢I V√Ä PH√ÇN T√çCH D·ªÆ LI·ªÜU T·ª™ FILE TXT ---
        // ----------------------------------------------------
        const loadAndParseLesson = async (lessonNumber) => {
            currentLesson = lessonNumber; 
            const filePath = `${BASE_PATH}bai${lessonNumber}/bai${lessonNumber}.txt`;
            
            try {
                //messageArea.textContent = `ƒêang t·∫£i d·ªØ li·ªáu B√†i ${lessonNumber}...`;

                const response = await fetch(filePath);
                if (!response.ok) {
                    throw new Error(`Kh√¥ng t√¨m th·∫•y file: ${filePath}`);
                }
                const text = await response.text();
                
                const lines = text.trim().split('\n');
                let newWordList = [];
                let wordsFiltered = 0; 
                // LESSON_AUDIO_TIMESTAMPS ƒë√£ ƒë∆∞·ª£c lo·∫°i b·ªè

                lines.forEach((line, index) => {
                    if (line.trim() === '' || line.startsWith('#') || line.startsWith('//')) return; 
                    
                    const parts = line.split('|').map(p => p.trim());
                    
                    if (parts.length < 6) {
                        console.warn(`D√≤ng ${index + 1} kh√¥ng ƒë·ªß 6 ph·∫ßn t·ª≠: ${line}`);
                        return;
                    } 

                    const hanzi = parts[0];
                    const pinyin = parts[1];
                    const vn = parts[2];
                    const exampleHanzi = parts[3];
                    
                    if (hanzi && pinyin) {
                        // L·ªåC: Ch·ªâ ch·∫•p nh·∫≠n t·ª´ c√≥ 2 √¢m ti·∫øt tr·ªü l√™n
                        if (hanzi.length >= 2) { 
                            const chars = hanzi.split('');
                            const wordId = `lesson${lessonNumber}_word${index}`;
                            
                            newWordList.push({
                                chars: chars, 
                                length: chars.length, 
                                pinyin: pinyin, 
                                vn: vn, 
                                example: exampleHanzi, 
                                id: wordId 
                            });
                            // Kh√¥ng c·∫ßn t·∫°o timestamp gi·∫£ ƒë·ªãnh n·ªØa
                        } else {
                            wordsFiltered++;
                        }
                    }
                });
                
                WORD_LIST_RAW = newWordList;
                WORD_LIST_WITH_IDS = newWordList;
                
                document.getElementById('total-words').textContent = WORD_LIST_RAW.length;
                
                window.restartGame(); 
                
                let successMessage = `ƒê√£ t·∫£i th√†nh c√¥ng ${WORD_LIST_RAW.length} t·ª´ v·ª±ng t·ª´ B√†i ${lessonNumber}.`;
                if (wordsFiltered > 0) {
                     successMessage += ` (ƒê√£ l·ªçc ${wordsFiltered} t·ª´ ƒë∆°n √¢m ti·∫øt)`;
                }
                //messageArea.textContent = successMessage;
                
            } catch (error) {
                console.error("L·ªói khi t·∫£i ho·∫∑c ph√¢n t√≠ch d·ªØ li·ªáu b√†i h·ªçc:", error);
                //messageArea.textContent = `L·ªói: Kh√¥ng th·ªÉ t·∫£i B√†i ${lessonNumber}. Vui l√≤ng ki·ªÉm tra l·∫°i ƒë∆∞·ªùng d·∫´n file.`;
                WORD_LIST_RAW = [];
                WORD_LIST_WITH_IDS = [];
                document.getElementById('total-words').textContent = 0;
            }
        };

        // --- C√ÅC H√ÄM H·ªñ TR·ª¢ V√Ä LOGIC GAME (Gi·ªØ nguy√™n) ---

        const calculateAndShufflePool = () => {
            let allChars = UNSOLVED_WORDS.flatMap(word => word.chars);
            allChars.sort(() => 0.5 - Math.random());
            AVAILABLE_CHAR_POOL = allChars;
        };
        
        const fillNewGrid = () => {
            if (UNSOLVED_WORDS.length === 0) {
                showVictoryModal();
                return;
            }

            gridState = [];
            
            const charsForGrid = AVAILABLE_CHAR_POOL.splice(0, TOTAL_CELLS); 
            
            for (let i = 0; i < TOTAL_CELLS; i++) {
                const char = charsForGrid[i] || ''; 
                gridState.push({ 
                    char: char, 
                    index: i, 
                    id: Date.now() + i + Math.random(), 
                    isEmpty: char === '' 
                }); 
            }
            renderGrid();
        };

        window.restartGame = () => {
            if (WORD_LIST_WITH_IDS.length === 0) {
                 messageArea.textContent = 'Vui l√≤ng ch·ªçn m·ªôt b√†i h·ªçc c√≥ d·ªØ li·ªáu.';
                 return;
            }

            isProcessing = false; 
            currentScore = 0;
            totalWordsMatched = 0;
            UNSOLVED_WORDS = [...WORD_LIST_WITH_IDS]; 
            selectedTiles = [];
            comboCount = 0;
            hintCount = 3;
            
            calculateAndShufflePool(); 

            scoreElement.textContent = currentScore;
            matchedCountElement.textContent = totalWordsMatched;
            totalWordsElement.textContent = WORD_LIST_WITH_IDS.length;
            selectionDisplay.textContent = '';
            hintCountElement.textContent = hintCount;
            hintBtn.disabled = false;
            
            gameoverTitleElement.textContent = 'H·∫æT GAME!';
            
            fillNewGrid();
            
            setTimeout(() => checkStuck(), 500); 
        };

        const getTileColor = (char) => {
            let charIsActive = UNSOLVED_WORDS.some(word => word.chars.includes(char));
            const isDarkMode = isDarkModeEnabled(); 
            if (charIsActive) {
                return isDarkMode ? DARK_TILE_COLOR : LIGHT_TILE_COLOR; 
            }
            return EMPTY_TILE_COLOR; 
        };

        const renderGrid = () => {
            gridElement.innerHTML = '';
            
            gridState.forEach((tile, index) => {
                const isSelected = selectedTiles.includes(index);
                const tileDiv = document.createElement('div');
                
                const isTileEmpty = tile.isEmpty || !tile.char;
                const colorScheme = isTileEmpty ? EMPTY_TILE_COLOR : getTileColor(tile.char);
                const tileBgColor = colorScheme.bg;
                const tileTextColor = colorScheme.text;
                
                tileDiv.className = `hanzi-tile rounded-xl 
                    ${isTileEmpty ? 'opacity-0 cursor-default pointer-events-none' : (isSelected ? 'selected' : '')}`;
                
                tileDiv.dataset.index = index;
                tileDiv.dataset.id = tile.id;
                tileDiv.onclick = isTileEmpty ? null : () => handleTileClick(index);

                tileDiv.style.backgroundColor = isSelected ? '' : tileBgColor;

                const contentDiv = document.createElement('div');
                contentDiv.className = 'hanzi-content';
                contentDiv.textContent = tile.char;
                
                contentDiv.style.color = isSelected ? '#ffffff' : tileTextColor;

                tileDiv.appendChild(contentDiv);
                gridElement.appendChild(tileDiv);
            });
            matchedCountElement.textContent = totalWordsMatched;
        };

        const updateSelectionDisplay = () => {
            const currentWord = selectedTiles.map(index => gridState[index].char).join('');
            selectionDisplay.textContent = currentWord;
        };

        const updateScoreUI = () => {
            scoreElement.textContent = currentScore;
        };

        const handleTileClick = (index) => {
            if (isProcessing) return;
            
            const tileDiv = gridElement.querySelector(`[data-index="${index}"]`);
            if (tileDiv) {
                tileDiv.classList.remove('animate-pulse', 'hint-pulse');
                tileDiv.style.backgroundColor = getTileColor(gridState[index].char).bg;
            }

            const tile = gridState[index];
            if (tile.isEmpty || !tile.char) return;

            if (selectedTiles.includes(index)) {
                selectedTiles = selectedTiles.filter(i => i !== index);
            } else {
                if (selectedTiles.length < 10) {
                    selectedTiles.push(index);
                } else {
                    selectedTiles = [index];
                }
            }

            updateSelectionDisplay();
            renderGrid();
            
            if (selectedTiles.length >= 2) {
                checkMatch();
            }
        };

        const checkMatch = () => {
            if (isProcessing) return;
            
            const currentWordChars = selectedTiles.map(index => gridState[index].char);
            const currentWord = currentWordChars.join('');
            
            const matchedWord = WORD_LIST_WITH_IDS.find(word => word.chars.join('') === currentWord);
            
            const isWordUnsolved = matchedWord && UNSOLVED_WORDS.some(w => w.id === matchedWord.id);

            if (isWordUnsolved) {
                handleMatchCorrect(matchedWord);
            } else if (selectedTiles.length === 10) {
                handleMatchWrong();
            }
        };
        
        const handleMatchCorrect = (matchedWord) => {
            isProcessing = true;
            totalWordsMatched++;
            comboCount++;
            
            UNSOLVED_WORDS = UNSOLVED_WORDS.filter(w => w.id !== matchedWord.id);
            
            selectedTiles.forEach(index => {
                const tile = gridElement.querySelector(`[data-index="${index}"]`);
                if (tile) {
                    tile.classList.remove('selected', 'animate-pulse', 'hint-pulse');
                    tile.classList.add('correct');
                    tile.style.backgroundColor = ''; 
                }
            });

            const basePoints = matchedWord.length === 2 ? 10 : (matchedWord.length === 3 ? 20 : 40);
            const multiplier = 1 + (comboCount - 1) * 0.5;
            const pointsGained = Math.round(basePoints * multiplier);
            
            animateFlyingScore(pointsGained, comboCount);

            currentScore += pointsGained;

            messageArea.textContent = `+${pointsGained} ƒêi·ªÉm! Combo x${comboCount}! `;
            updateScoreUI();
            
            if (currentScore > bestScore) {
                bestScore = currentScore;
                bestScoreElement.textContent = bestScore;
                if (window.saveBestScore) window.saveBestScore(currentScore);
            }
            
            showDictionaryModal(matchedWord);

            selectedTiles = [];
            selectionDisplay.textContent = '';
            
            if (UNSOLVED_WORDS.length === 0) {
                setTimeout(() => showVictoryModal(), 500);
                return;
            }
            
            calculateAndShufflePool(); 
            
            setTimeout(() => {
                gridElement.querySelectorAll('.hanzi-tile').forEach(tile => {
                     tile.classList.remove('correct');
                });
                
                fillNewGrid(); 
                isProcessing = false;
                checkStuck(); 
            }, 500);
        };

        const handleMatchWrong = () => {
            isProcessing = true;
            comboCount = 0;
            messageArea.textContent = 'Gh√©p sai! Combo b·ªã reset.';
            
            selectedTiles.forEach(index => {
                const tile = gridElement.querySelector(`[data-index="${index}"]`);
                if (tile) {
                    tile.classList.remove('selected', 'animate-pulse', 'hint-pulse'); 
                    tile.classList.add('wrong');
                }
            });

            setTimeout(() => {
                selectedTiles.forEach(index => {
                    const tile = gridElement.querySelector(`[data-index="${index}"]`);
                    if (tile) {
                        tile.classList.remove('wrong');
                    }
                });
                selectedTiles = [];
                selectionDisplay.textContent = '';
                isProcessing = false;
                
                renderGrid(); 
                checkStuck(); 
            }, 600);
        };
        
        const findHint = () => {
            const currentTiles = gridState.filter(t => t.char && t.char !== '' && !t.isEmpty);
            const currentChars = currentTiles.map(t => t.char);
            
            if (currentChars.length < 2) return null;

            for (const word of UNSOLVED_WORDS) {
                let tempChars = [...currentChars];
                let isPossible = true;
                
                for (const char of word.chars) {
                    const charIndex = tempChars.indexOf(char);
                    if (charIndex > -1) {
                        tempChars.splice(charIndex, 1);
                    } else {
                        isPossible = false;
                        break;
                    }
                }

                if (isPossible) {
                    return word;
                }
            }
            return null;
        };
        
        const handleHint = () => {
            if (hintCount <= 0 || isProcessing) return;

            const hint = findHint();
            
            const isDarkMode = isDarkModeEnabled();
            const hintClass = 'hint-pulse'; 
            
            const hintBg = isDarkMode ? DARK_TILE_COLOR.bg : LIGHT_MODE_HINT_COLOR;
            const hintText = isDarkMode ? DARK_TILE_COLOR.text : LIGHT_MODE_HINT_TEXT_COLOR;

            if (hint) {
                hintCount--;
                hintCountElement.textContent = hintCount;
                if (hintCount === 0) hintBtn.disabled = true;

                let tempGridState = [...gridState];
                let hintIndexes = [];

                hint.chars.forEach(char => {
                    const index = tempGridState.findIndex(tile => tile.char === char && !tile.isEmpty);
                    if (index > -1) {
                        hintIndexes.push(index);
                        tempGridState[index] = { char: null, index, isEmpty: true }; 
                    }
                });
                
                selectedTiles = [];
                selectionDisplay.textContent = '';
                renderGrid(); 

                hintIndexes.forEach(index => {
                    const tile = gridElement.querySelector(`[data-index="${index}"]`);
                    if (tile) {
                        const content = tile.querySelector('.hanzi-content');
                        
                        tile.style.backgroundColor = hintBg;
                        content.style.color = hintText;

                        tile.classList.add('animate-pulse', hintClass);
                        
                        setTimeout(() => {
                            tile.classList.remove('animate-pulse', hintClass);
                            const originalColor = getTileColor(gridState[index].char);
                            tile.style.backgroundColor = originalColor.bg;
                            content.style.color = originalColor.text;

                        }, 1500);
                    }
                });

                messageArea.textContent = `G·ª£i √Ω: H√£y gh√©p ${hint.chars.join(' + ')}!`;
            } else {
                messageArea.textContent = 'Kh√¥ng t√¨m th·∫•y t·ª´ n√†o kh·∫£ thi l√∫c n√†y.';
            }
        };

        const showDictionaryModal = (word) => {
            const modal = document.getElementById('dictionary-modal');
            const hanziText = word.chars.join('');
            
            document.getElementById('modal-hanzi').textContent = hanziText;
            document.getElementById('modal-pinyin').textContent = word.pinyin;
            document.getElementById('modal-vn').textContent = word.vn;
            document.getElementById('modal-example-text').textContent = word.example;
            
            currentHanziToSpeak = hanziText;
            speakerBtn.disabled = false;
            speakerBtn.textContent = 'üîä'; 
            
            modal.classList.remove('hidden');
            modal.classList.add('flex');
            setTimeout(() => {
                modal.querySelector('div').classList.remove('scale-95');
                modal.querySelector('div').classList.add('scale-100');
            }, 10);
            
            // S·ª¨ D·ª§NG H√ÄM PH√ÅT √ÇM ∆ØU TI√äN MP3 T·ª™ FILE RI√äNG L·∫∫
            playAudioFromLesson(currentLesson, currentHanziToSpeak);

            setTimeout(() => {
                window.speechSynthesis.cancel(); 
                audioPlayer.pause(); 
                modal.classList.add('hidden');
                modal.querySelector('div').classList.remove('scale-100');
                modal.querySelector('div').classList.add('scale-95');
                speakerBtn.textContent = 'üîä';
                speakerBtn.disabled = false;
            }, 2000); 
        };
        
        const handleStuckGrid = () => {
            isProcessing = true;
            messageArea.textContent = 'L∆∞·ªõi b·ªã k·∫πt! ƒêang thu h·ªìi v√† ƒë·ªï l·∫°i 16 ch·ªØ H√°n m·ªõi...';
            
            const stuckChars = gridState.filter(t => !t.isEmpty).map(t => t.char);
            AVAILABLE_CHAR_POOL.push(...stuckChars); 
            
            AVAILABLE_CHAR_POOL.sort(() => 0.5 - Math.random());

            fillNewGrid(); 

            setTimeout(() => {
                messageArea.textContent = 'ƒê√£ ƒë·ªï l·∫°i l∆∞·ªõi m·ªõi.';
                isProcessing = false;
                
                checkStuck(); 
            }, 500);
        };
        
        const showVictoryModal = () => {
            const modal = document.getElementById('gameover-modal');
            gameoverTitleElement.textContent = 'CHI·∫æN TH·∫ÆNG TUY·ªÜT V·ªúI! üèÜ';
            gameoverTitleElement.classList.remove('text-red-600');
            gameoverTitleElement.classList.add('text-green-600');

            document.getElementById('final-score').textContent = currentScore;
            
            let updateMessage = `B·∫°n ƒë√£ ho√†n th√†nh T·∫§T C·∫¢ ${WORD_LIST_WITH_IDS.length} t·ª´ trong danh s√°ch!`;
            if (currentScore > bestScore) {
                updateMessage += ' B·∫°n ƒë√£ l·∫≠p k·ª∑ l·ª•c ƒëi·ªÉm cao m·ªõi!';
            }
            document.getElementById('best-score-update').textContent = updateMessage;
            
            modal.classList.remove('hidden');
            modal.classList.add('flex');
            
            isProcessing = true; 

            triggerConfetti();
        };
        
        const checkStuck = () => {
             if (isProcessing || UNSOLVED_WORDS.length === 0) return;

             const hasPossibleMoves = findHint() !== null; 

             if (!hasPossibleMoves) {
                handleStuckGrid();
             }
        };

        const triggerConfetti = () => {
            confetti({
                particleCount: 100,
                spread: 70,
                origin: { y: 0.6 }
            });

            const defaults = {
                spread: 360,
                ticks: 50,
                gravity: 0.5,
                decay: 0.94,
                startVelocity: 30,
                colors: ['#00FF00', '#FFFF00', '#FF00FF', '#00FFFF', '#FF6600']
            };

            function fire(particleRatio, opts) {
                confetti(Object.assign({}, defaults, opts, {
                    particleCount: Math.floor(250 * particleRatio)
                }));
            }

            fire(0.25, {
                spread: 26,
                startVelocity: 55,
            });
            fire(0.2, {
                spread: 60,
            });
            fire(0.35, {
                spread: 100,
                decay: 0.91,
                scalar: 0.8
            });
            fire(0.1, {
                spread: 120,
                startVelocity: 25,
                decay: 0.92,
                scalar: 1.2
            });
            fire(0.1, {
                spread: 120,
                startVelocity: 45,
            });
        };

        const animateFlyingScore = (pointsGained, comboCount) => {
            const scoreElementRect = scoreElement.getBoundingClientRect();
            const scoreTargetX = scoreElementRect.right - 10; 
            const scoreTargetY = scoreElementRect.top + scoreElementRect.height / 2;
            if (selectedTiles.length === 0) return;
            const sourceIndex = selectedTiles[0];
            const sourceTile = gridElement.querySelector(`[data-index="${sourceIndex}"]`);
            if (!sourceTile) return;
            const sourceRect = sourceTile.getBoundingClientRect();
            const sourceCenterX = sourceRect.left + sourceRect.width / 2;
            const sourceCenterY = sourceRect.top + sourceRect.height / 2;
            const flyEl = document.createElement('div');
            const comboText = comboCount > 1 ? ` (x${comboCount})` : '';
            flyEl.textContent = `+${pointsGained}${comboText}`;
            flyEl.className = 'flying-score';
            flyEl.style.left = `${sourceCenterX}px`;
            flyEl.style.top = `${sourceCenterY}px`;
            document.body.appendChild(flyEl);
            setTimeout(() => {
                const dx = scoreTargetX - sourceCenterX;
                const dy = scoreTargetY - sourceCenterY;
                flyEl.style.transform = `translate(${dx}px, ${dy}px) scale(0.5)`;
                flyEl.style.opacity = '0';
            }, 10);
            setTimeout(() => {
                flyEl.remove();
            }, 800); 
        };

        const isDarkModeEnabled = () => {
            return document.documentElement.classList.contains('dark');
        };

        const applyDarkMode = (isDark) => {
            if (isDark) {
                document.documentElement.classList.add('dark');
                document.getElementById('game-container').classList.remove('bg-white', 'shadow-2xl');
                document.getElementById('game-container').classList.add('bg-gray-800', 'shadow-xl');
                darkModeIcon.textContent = '‚òÄÔ∏è';
                localStorage.setItem('theme', 'dark');
            } else {
                document.documentElement.classList.remove('dark');
                document.getElementById('game-container').classList.add('bg-white', 'shadow-2xl');
                document.getElementById('game-container').classList.remove('bg-gray-800', 'shadow-xl');
                darkModeIcon.textContent = 'üåô';
                localStorage.setItem('theme', 'light');
            }
            renderGrid();
        };
        
        const toggleDarkMode = () => {
            applyDarkMode(!isDarkModeEnabled());
        };

        window.onload = function() {
            document.getElementById('restart-btn').onclick = window.restartGame;
            document.getElementById('hint-btn').onclick = handleHint; 
            darkModeToggle.onclick = toggleDarkMode;
            
            // ƒê·∫£m b·∫£o n√∫t loa g·ªçi h√†m x·ª≠ l√Ω MP3/TTS
            speakerBtn.onclick = handleSpeakerClick; 
            
            lessonSelect.onchange = (event) => {
                const selectedLesson = event.target.value;
                loadAndParseLesson(selectedLesson);
            };

            const savedTheme = localStorage.getItem('theme');
            if (savedTheme === 'dark' || (!savedTheme && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
                applyDarkMode(true);
            } else {
                applyDarkMode(false);
            }
            
            loadAndParseLesson(lessonSelect.value);
        };
    </script>
</body>
</html>
