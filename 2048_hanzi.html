<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2048 C·ªï ƒêi·ªÉn</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Confetti Library for High Score celebration -->
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    <!-- Use Inter font -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #faf8ef;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            /* FIX 1: NgƒÉn ch·∫∑n cu·ªôn d·ªçc (ƒë·ªÉ tr√°nh pull-to-refresh) */
            overflow: hidden; 
        }
        /* FIX 2: ƒê·∫£m b·∫£o container n·ªôi dung c√≥ th·ªÉ cu·ªôn n·∫øu c·∫ßn, nh∆∞ng ch·ªâ khi n·ªôi dung v∆∞·ª£t qu√° chi·ªÅu cao m√†n h√¨nh */
        .container-wrapper {
             overflow-y: auto;
             -webkit-overflow-scrolling: touch;
             height: 100vh;
             width: 100%;
             max-width: 600px;
             padding: 20px 0; /* Padding d·ªçc ƒë·ªÉ n·ªôi dung kh√¥ng ch·∫°m m√©p */
             display: flex;
             flex-direction: column;
             align-items: center;
        }

        /* Custom Tailwind config for tile colors */
        .tile-container {
            position: relative;
            background-color: #bbada0;
            border-radius: 8px;
            padding: 8px; /* For spacing between cells */
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 1fr);
            gap: 8px;
            max-width: 600px; /* Max width for desktop */
            width: 100%;
            aspect-ratio: 1 / 1;
        }
        .cell {
            background-color: rgba(238, 228, 218, 0.35);
            border-radius: 6px;
            aspect-ratio: 1 / 1;
        }
        .tile {
            position: absolute;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: 900;
            color: #776e65;
            border-radius: 6px;
            
            /* √Åp d·ª•ng Transition cho transform ƒë·ªÉ t·∫°o hi·ªáu ·ª©ng chuy·ªÉn ƒë·ªông m∆∞·ª£t m√† */
            transition: transform 0.15s ease-in-out, background-color 0.15s ease-in-out;
            
            /* C·ªë ƒë·ªãnh k√≠ch th∆∞·ªõc tile b·∫±ng c√°ch t√≠nh to√°n l·∫°i */
            width: calc((100% - 32px) / 4); 
            height: calc((100% - 32px) / 4);
            
            /* D√πng top/left b·∫±ng 0 v√† d√πng transform ƒë·ªÉ ƒë·ªãnh v·ªã */
            top: 0;
            left: 0;
            
            /* D√πng CSS variable ƒë·ªÉ ƒë·∫∑t v·ªã tr√≠ ban ƒë·∫ßu cho animation */
            transform: translate(var(--x), var(--y));
        }
        
        /* Hi·ªáu ·ª©ng Pop-in khi √¥ m·ªõi xu·∫•t hi·ªán */
        .tile-new {
            animation: tile-pop 0.15s ease-in-out;
            transform: translate(var(--x), var(--y)) scale(0);
        }
        @keyframes tile-pop {
            0% { transform: translate(var(--x), var(--y)) scale(0.5); }
            100% { transform: translate(var(--x), var(--y)) scale(1); }
        }

        /* Classes m√†u v√† k√≠ch th∆∞·ªõc ch·ªØ */
        .tile-value-2 { background-color: #eee4da; font-size: 2.5rem; }
        .tile-value-4 { background-color: #ede0c8; font-size: 2.5rem; }
        .tile-value-8 { background-color: #f2b179; color: #f9f6f2; font-size: 2.5rem; }
        .tile-value-16 { background-color: #f59563; color: #f9f6f2; font-size: 2.2rem; }
        .tile-value-32 { background-color: #f67c5f; color: #f9f6f2; font-size: 2.2rem; }
        .tile-value-64 { background-color: #f65e3b; color: #f9f6f2; font-size: 2rem; }
        .tile-value-128 { background-color: #edcf72; color: #f9f6f2; font-size: 1.8rem; }
        .tile-value-256 { background-color: #edcc61; color: #f9f6f2; font-size: 1.8rem; }
        .tile-value-512 { background-color: #edc850; color: #f9f6f2; font-size: 1.6rem; }
        .tile-value-1024 { background-color: #edc53f; color: #f9f6f2; font-size: 1.6rem; }
        .tile-value-2048 { background-color: #edc22e; color: #f9f6f2; font-size: 1.4rem; }
        .tile-value-super { background-color: #3c3a32; color: #f9f6f2; font-size: 1.4rem; }
        
        /* Adjust font size for smaller screens (Mobile) */
        @media (max-width: 480px) {
            .tile-value-2, .tile-value-4, .tile-value-8 { font-size: 2rem; }
            .tile-value-16, .tile-value-32, .tile-value-64 { font-size: 1.6rem; }
            .tile-value-128, .tile-value-256, .tile-value-512 { font-size: 1.4rem; }
            .tile-value-1024, .tile-value-2048, .tile-value-super { font-size: 1.2rem; }
        }
        
        /* ƒêi·ªÅu ch·ªânh k√≠ch th∆∞·ªõc font cho Ch·ªØ H√°n */
        .tile.han-mode {
             /* Gi·∫£m k√≠ch th∆∞·ªõc font cho c√°c k√Ω t·ª± H√°n t·ª± ƒë·ªÉ d·ªÖ ƒë·ªçc h∆°n */
            font-size: 2.5rem;
            line-height: 1; /* CƒÉn ch·ªânh chi·ªÅu cao d√≤ng */
        }
        @media (max-width: 480px) {
             .tile.han-mode {
                font-size: 2rem;
            }
        }

        /* Game State Overlay */
        .game-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(250, 248, 239, 0.7);
            border-radius: 8px;
            z-index: 10;
            transition: opacity 0.5s;
        }

        /* Control Button Style - C·∫≠p nh·∫≠t k√≠ch th∆∞·ªõc nh·ªè h∆°n cho mobile */
        .control-btn {
            background-color: #8f7a66;
            color: white;
            font-size: 1.1rem;
            font-weight: bold;
            padding: 0.5rem;
            border-radius: 6px; /* Nh·ªè h∆°n so v·ªõi 8px */
            box-shadow: 0 3px #776e65; /* Nh·ªè h∆°n so v·ªõi 4px */
            transition: all 0.1s;
            width: 50px; /* Gi·∫£m k√≠ch th∆∞·ªõc */
            height: 50px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .control-btn:hover {
            background-color: #9f8a75;
        }
        .control-btn:active {
            box-shadow: 0 1px #776e65; /* Nh·ªè h∆°n so v·ªõi 2px */
            transform: translateY(2px);
        }
        
        /* Grid layout for D-pad (C·∫§U H√åNH M·ªöI) */
        .dpad-grid {
            display: grid;
            /* ƒê·ªãnh nghƒ©a b·ªë c·ª•c 3x3 nh∆∞ng ch·ªâ s·ª≠ d·ª•ng c√°c v·ªã tr√≠ 
               ƒë·ªÉ t·∫°o ra h√¨nh ch·ªØ T ng∆∞·ª£c:
               .  Up  .
               Lef Down Righ
            */
            grid-template-areas: 
                ". up ."
                "left down right";
            gap: 10px;
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr; /* Ch·ªâ c·∫ßn 2 h√†ng cho b·ªë c·ª•c m·ªõi */
            width: 170px; /* Gi·∫£m chi·ªÅu r·ªông t·ªïng th·ªÉ */
            height: 120px; /* Gi·∫£m chi·ªÅu cao t·ªïng th·ªÉ */
            align-items: center;
        }
        .dpad-up { grid-area: up; justify-self: center; }
        .dpad-left { grid-area: left; justify-self: end; }
        .dpad-right { grid-area: right; justify-self: start; }
        .dpad-down { grid-area: down; justify-self: center; }

        /* ƒêi·ªÅu ch·ªânh cho mobile ƒë·ªÉ b·ªë c·ª•c n√∫t kh√¥ng qu√° l·ªõn */
        @media (max-width: 480px) {
            .container {
                padding: 10px;
            }
            .dpad-grid {
                width: 150px; 
                height: 100px;
                gap: 8px;
            }
            .control-btn {
                width: 45px;
                height: 45px;
                font-size: 1rem;
            }
        }
    </style>
</head>
<body>
    <!-- Bao b·ªçc n·ªôi dung b·∫±ng m·ªôt div ƒë·ªÉ ki·ªÉm so√°t vi·ªác cu·ªôn -->
    <div class="container-wrapper">
        <div class="container w-full max-w-xl mx-auto p-4">
            <!-- Header -->
            <header class="mb-4">
                <div class="flex justify-between items-center mb-4">
                    <h1 class="text-6xl font-black text-[#776e65]">2048</h1>
                    <!-- Game Mode Selector -->
                    <div>
                        <label for="game-mode" class="text-xs font-semibold uppercase text-[#776e65] block mb-1 text-right">Ki·ªÉu ch∆°i</label>
                        <select id="game-mode" class="bg-white border border-[#bbada0] text-[#776e65] rounded-lg p-1.5 shadow-md text-sm cursor-pointer focus:ring-2 focus:ring-[#8f7a66] transition">
                            <option value="classic">C·ªï ƒëi·ªÉn (S·ªë)</option>
                            <option value="han">Ch·ªØ H√°n</option>
                        </select>
                    </div>
                </div>
                <div class="flex justify-end space-x-2">
                    <!-- Score Board -->
                    <div class="bg-[#bbada0] text-white p-2 rounded-lg text-center min-w-[80px]">
                        <div class="text-xs font-semibold uppercase opacity-80">ƒêi·ªÉm s·ªë</div>
                        <div id="score" class="text-xl font-bold">0</div>
                    </div>
                    <!-- High Score Board -->
                    <div class="bg-[#bbada0] text-white p-2 rounded-lg text-center min-w-[80px]">
                        <div class="text-xs font-semibold uppercase opacity-80">üèÜ</div>
                        <div id="high-score" class="text-xl font-bold">0</div>
                    </div>
                    <!-- New Game Button -->
                    <button id="new-game-btn" class="bg-[#8f7a66] hover:bg-[#9f8a75] text-white font-bold py-2 px-4 rounded-lg shadow-md transition-all">
                        New game
                    </button>
                </div>
            </header>

            <!-- Instructions -->
            <p class="text-center text-[#776e65] mb-4 text-sm md:text-base">
                S·ª≠ d·ª•ng ph√≠m m≈©i t√™n ho·∫∑c l∆∞·ªõt (swipe) tr√™n m√†n h√¨nh ƒë·ªÉ di chuy·ªÉn c√°c √¥.
            </p>

            <!-- Game Board Container -->
            <div id="game-container" class="tile-container relative">
                <!-- Grid Cells (Background) -->
                <div class="grid grid-cols-4 gap-2 absolute inset-0 p-2">
                    <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
                    <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
                    <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
                    <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
                </div>
                <!-- Tiles will be appended here -->

                <!-- Game Over/Win Overlay -->
                <div id="game-overlay" class="game-overlay hidden">
                    <p id="overlay-message" class="text-4xl font-black text-[#776e65] mb-4"></p>
                    <button id="try-again-btn" class="bg-[#8f7a66] hover:bg-[#9f8a75] text-white font-bold py-3 px-6 rounded-lg shadow-xl text-lg transition-all">
                        Th·ª≠ l·∫°i
                    </button>
                </div>
            </div>
            
            <!-- --- Control Buttons (D-Pad) --- -->
            <!-- Th√™m class 'hidden' ƒë·ªÉ ·∫©n b·ªô ƒëi·ªÅu khi·ªÉn D-pad -->
            <div class="flex justify-center mt-8 hidden"> 
                <div class="dpad-grid">
                    <button id="btn-up" class="control-btn dpad-up">‚ñ≤</button>
                    <button id="btn-left" class="control-btn dpad-left">‚óÄ</button>
                    <button id="btn-down" class="control-btn dpad-down">‚ñº</button>
                    <button id="btn-right" class="control-btn dpad-right">‚ñ∂</button>
                </div>
            </div>
            <!-- --- End Control Buttons --- -->
            
        </div>
    </div>
    <!-- FIX 3: NgƒÉn ch·∫∑n h√†nh vi cu·ªôn m·∫∑c ƒë·ªãnh c·ªßa t√†i li·ªáu (ch·ªâ ho·∫°t ƒë·ªông v·ªõi m·ªôt s·ªë tr√¨nh duy·ªát) -->
    <script>
        document.addEventListener('touchmove', (e) => {
            // NgƒÉn ch·∫∑n cu·ªôn n·∫øu s·ª± ki·ªán touch x·∫£y ra tr√™n b·∫•t k·ª≥ ƒë√¢u trong body
            // Ngo·∫°i tr·ª´ c√°c ph·∫ßn t·ª≠ c√≥ th·ªÉ cu·ªôn (n·∫øu c√≥, nh∆∞ng ·ªü ƒë√¢y kh√¥ng c·∫ßn)
            e.preventDefault();
        }, { passive: false });
    </script>
    
    <script>
        // --- Tailwind CSS Configuration for colors (must be before first tile is drawn) ---
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'tile-bg-0': '#cdc1b4',
                        'tile-bg-2': '#eee4da',
                        'tile-bg-4': '#ede0c8',
                        'tile-bg-8': '#f2b179',
                        'tile-bg-16': '#f59563',
                        'tile-bg-32': '#f67c5f',
                        'tile-bg-64': '#f65e3b',
                        'tile-bg-128': '#edcf72',
                        'tile-bg-256': '#edcc61',
                        'tile-bg-512': '#edc850',
                        'tile-bg-1024': '#edc53f',
                        'tile-bg-2048': '#edc22e',
                    },
                    boxShadow: {
                        'tile': '0 0 10px rgba(0, 0, 0, 0.1), 0 4px 6px rgba(0, 0, 0, 0.05)',
                    }
                }
            }
        }
    </script>

    <script>
        const GRID_SIZE = 4;
        const TILE_GAP_PX = 8;
        const CONTAINER_PADDING_PX = 8;
        const ANIMATION_DURATION = 150; // ms
        const HIGH_SCORE_KEY = '2048_high_score'; // Key for localStorage
        
        // √Ånh x·∫° c√°c gi√° tr·ªã s·ªë sang k√Ω t·ª± H√°n t·ª±
        const HANZI_MAP = {
            2: '‰Ω†',    // N«ê - You
            4: 'Êàë',    // W«í - I/Me
            8: 'ÊÇ®',    // TƒÅ - He/Him
            16: 'Â•Ω',   // H«éo - Good
            32: 'Â≠¶',   // Xu√© - Study/Learn
            64: 'Áîü',   // Shƒìng - Student/Life
            128: 'ËÄÅ',  // D√† - Big/Large
            256: 'Â∏à',  // JiƒÅ - Family/Home
            512: 'ÂÜç',  // De - Possessive/Adjectival Particle
            1024: 'ËßÅ', // P√©ng - Friend (first part of P√®ngyou - Friend)
            2048: '', // Y«íu - Friend (second part of P√®ngyou - Friend)
            // Ti·∫øp t·ª•c cho c√°c c·∫•p ƒë·ªô cao h∆°n
            4096: 'Ëøô',  // X«ê - Happy/Like
            8192: 'ÈÇ£', // HuƒÅn - Happy/Joyful
            16384: 'ÂõΩ', // Zh≈çng - Middle/China
            32768: 'ÂÆâ', // W√©n - Language/Culture
            65536: 'Áà±'  // √Äi - Love
        };
        
        let board; // L∆∞u tr·ªØ c√°c ƒë·ªëi t∆∞·ª£ng { value, id } ho·∫∑c null
        let score = 0;
        let highScore = 0; // Th√™m bi·∫øn ƒëi·ªÉm cao nh·∫•t
        let isGameOver = false;
        let hasWon = false;
        let TILE_SIZE_PX = 0; // K√≠ch th∆∞·ªõc pixel th·ª±c t·∫ø c·ªßa m·ªôt √¥
        let tileIdCounter = 0; // B·ªô ƒë·∫øm ID duy nh·∫•t cho m·ªói √¥
        let gameMode = 'classic'; // Ki·ªÉu ch∆°i hi·ªán t·∫°i

        const gameContainer = document.getElementById('game-container');
        const scoreElement = document.getElementById('score');
        const highScoreElement = document.getElementById('high-score'); // Element m·ªõi
        const overlay = document.getElementById('game-overlay');
        const overlayMessage = document.getElementById('overlay-message');
        const newGameBtn = document.getElementById('new-game-btn');
        const tryAgainBtn = document.getElementById('try-again-btn');
        const gameModeSelector = document.getElementById('game-mode'); // Element m·ªõi
        
        // --- N√∫t ƒëi·ªÅu khi·ªÉn m·ªõi ---
        const btnUp = document.getElementById('btn-up');
        const btnLeft = document.getElementById('btn-left');
        const btnRight = document.getElementById('btn-right');
        const btnDown = document.getElementById('btn-down');

        // H√†m t·∫£i ƒëi·ªÉm cao nh·∫•t t·ª´ localStorage
        function loadHighScore() {
            try {
                const storedScore = localStorage.getItem(HIGH_SCORE_KEY);
                highScore = parseInt(storedScore) || 0;
            } catch (e) {
                console.error("Kh√¥ng th·ªÉ t·∫£i ƒëi·ªÉm cao nh·∫•t t·ª´ localStorage:", e);
                highScore = 0;
            }
            updateHighScoreDisplay();
        }

        // H√†m c·∫≠p nh·∫≠t hi·ªÉn th·ªã ƒëi·ªÉm cao nh·∫•t (FIX: ƒê∆∞a l√™n ƒë√¢y ƒë·ªÉ ƒë·∫£m b·∫£o ph·∫°m vi truy c·∫≠p)
        function updateHighScoreDisplay() {
            highScoreElement.textContent = highScore;
        }

        // H√†m ki·ªÉm tra v√† c·∫≠p nh·∫≠t ƒëi·ªÉm cao nh·∫•t - D·ª™NG G·ªåI H√ÄM N√ÄY SAU M·ªñI B∆Ø·ªöC ƒêI.
        // N√≥ s·∫Ω ƒë∆∞·ª£c g·ªçi M·ªòT L·∫¶N trong checkGameState() khi game over.
        function checkAndUpdateHighScoreOnGameOver() {
            if (score > highScore) {
                // ƒê√¢y l√† k·ª∑ l·ª•c m·ªõi
                highScore = score;
                updateHighScoreDisplay();
                
                // K√≠ch ho·∫°t ph√°o gi·∫•y v√† th√¥ng b√°o ch√∫c m·ª´ng
                launchConfetti();
                showOverlay("K·ª∑ l·ª•c m·ªõi: " + score + "!", "win"); // D√πng "win" ƒë·ªÉ c√≥ m√†u v√†ng
                
                // L∆∞u v√†o localStorage
                try {
                    localStorage.setItem(HIGH_SCORE_KEY, highScore.toString());
                } catch (e) {
                    console.error("Kh√¥ng th·ªÉ l∆∞u ƒëi·ªÉm cao nh·∫•t v√†o localStorage:", e);
                }
                return true; // ƒê√£ ƒë·∫°t k·ª∑ l·ª•c m·ªõi
            }
            return false; // Kh√¥ng ƒë·∫°t k·ª∑ l·ª•c m·ªõi
        }
        
        // H√†m b·∫Øn ph√°o gi·∫•y ch√∫c m·ª´ng
        function launchConfetti() {
            const duration = 5 * 1000;
            const animationEnd = Date.now() + duration;
            const defaults = { startVelocity: 30, spread: 360, ticks: 60, zIndex: 9999 };

            function randomInRange(min, max) {
                return Math.random() * (max - min) + min;
            }

            const interval = setInterval(function() {
                const timeLeft = animationEnd - Date.now();

                if (timeLeft <= 0) {
                    return clearInterval(interval);
                }

                const particleCount = 50 * (timeLeft / duration);
                // since particles fall down, start a bit higher than random
                confetti(Object.assign({}, defaults, { particleCount, origin: { x: randomInRange(0.1, 0.3), y: Math.random() - 0.2 } }));
                confetti(Object.assign({}, defaults, { particleCount, origin: { x: randomInRange(0.7, 0.9), y: Math.random() - 0.2 } }));
            }, 250);
        }

        // H√†m t·∫°o ƒë·ªëi t∆∞·ª£ng √¥ m·ªõi
        function createTile(value) {
            return { value, id: `t${tileIdCounter++}` };
        }

        // Initial setup function
        function setupGame() {
            board = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(null));
            score = 0;
            isGameOver = false;
            hasWon = false;
            overlay.classList.add('hidden');
            gameContainer.innerHTML = ''; // Clear existing tiles and overlay
            
            // Re-add the background cells and overlay structure
            addBackgroundCells();
            gameContainer.appendChild(overlay);

            updateScore(); // C·∫≠p nh·∫≠t hi·ªÉn th·ªã ƒëi·ªÉm hi·ªán t·∫°i (l√† 0)
            updateHighScoreDisplay(); // FIX: G·ªçi h√†m c·∫≠p nh·∫≠t hi·ªÉn th·ªã ƒëi·ªÉm cao nh·∫•t
            
            addRandomTile();
            addRandomTile();
            updateTiles(); // D√πng updateTiles thay cho drawBoard
        }

        function addBackgroundCells() {
             const bgDiv = document.createElement('div');
             bgDiv.className = 'grid grid-cols-4 gap-2 absolute inset-0 p-2';
             for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
                 const cell = document.createElement('div');
                 cell.className = 'cell';
                 bgDiv.appendChild(cell);
             }
             gameContainer.appendChild(bgDiv);
             
             // C·∫≠p nh·∫≠t TILE_SIZE_PX d·ª±a tr√™n k√≠ch th∆∞·ªõc th·ª±c t·∫ø c·ªßa m·ªôt √¥ n·ªÅn
             const firstCell = gameContainer.querySelector('.cell');
             if (firstCell) {
                 TILE_SIZE_PX = firstCell.offsetWidth;
             }
        }

        // Updates the score display
        function updateScore() {
            scoreElement.textContent = score;
            // X√≥a checkAndUpdateHighScore() ·ªü ƒë√¢y
        }

        // Finds all empty cells (l√† null)
        function getEmptyCells() {
            let cells = [];
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    if (board[r][c] === null) {
                        cells.push({ r, c });
                    }
                }
            }
            return cells;
        }

        // Adds a new 2 or 4 tile to a random empty cell
        function addRandomTile() {
            const emptyCells = getEmptyCells();
            if (emptyCells.length === 0) return;

            const { r, c } = emptyCells[Math.floor(Math.random() * emptyCells.length)];
            const value = Math.random() < 0.9 ? 2 : 4;
            board[r][c] = createTile(value); // D√πng h√†m t·∫°o tile
        }
        
        // H√†m chuy·ªÉn ƒë·ªïi gi√° tr·ªã s·ªë sang chu·ªói hi·ªÉn th·ªã
        function getTileContent(value) {
            if (gameMode === 'han' && HANZI_MAP.hasOwnProperty(value)) {
                return HANZI_MAP[value];
            }
            return value.toString();
        }

        /**
         * Chuy·ªÉn ƒë·ªïi t·ªça ƒë·ªô h√†ng/c·ªôt (r, c) th√†nh gi√° tr·ªã pixel cho CSS Transform.
         */
        function getPosition(r, c) {
            // V·ªã tr√≠ X (c·ªôt): c * (K√≠ch th∆∞·ªõc √¥ + Kho·∫£ng c√°ch) + Padding c·ªßa container
            const x = c * (TILE_SIZE_PX + TILE_GAP_PX) + CONTAINER_PADDING_PX;
            const y = r * (TILE_SIZE_PX + TILE_GAP_PX) + CONTAINER_PADDING_PX;
            
            return { x: `${x}px`, y: `${y}px` };
        }

        /**
         * C·∫≠p nh·∫≠t c√°c √¥ tr√™n m√†n h√¨nh (thay th·∫ø drawBoard)
         * H√†m n√†y √°p d·ª•ng animation cho c√°c √¥ di chuy·ªÉn v√† √¥ m·ªõi.
         */
        function updateTiles() {
            // L·∫•y c√°c √¥ hi·ªán c√≥ trong DOM theo ID
            const existingTiles = new Map();
            gameContainer.querySelectorAll('.tile').forEach(tile => {
                existingTiles.set(tile.id, tile);
            });

            // Recalculate TILE_SIZE_PX (ƒë·∫£m b·∫£o responsive)
            const firstCell = gameContainer.querySelector('.cell');
            if (firstCell) {
                 TILE_SIZE_PX = firstCell.offsetWidth;
            }
            
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const tileData = board[r][c];
                    const { x, y } = getPosition(r, c);
                    
                    if (tileData) {
                        let tileElement = existingTiles.get(tileData.id);
                        const displayContent = getTileContent(tileData.value);
                        
                        // X√°c ƒë·ªãnh class cho ch·∫ø ƒë·ªô ch∆°i
                        const modeClass = gameMode === 'han' ? 'han-mode' : '';

                        if (tileElement) {
                            // √î ƒë√£ t·ªìn t·∫°i: √Åp d·ª•ng v·ªã tr√≠ m·ªõi (CSS Transition s·∫Ω t·ª± ƒë·ªông t·∫°o chuy·ªÉn ƒë·ªông)
                            
                            // C·∫≠p nh·∫≠t gi√° tr·ªã transform
                            tileElement.style.transform = `translate(${x}, ${y})`;
                            
                            // C·∫≠p nh·∫≠t gi√° tr·ªã hi·ªÉn th·ªã v√† m√†u s·∫Øc (trong tr∆∞·ªùng h·ª£p √¥ ƒë√£ ƒë∆∞·ª£c merge)
                            const classNameValue = tileData.value > 65536 ? 'super' : tileData.value;
                            tileElement.className = `tile tile-value-${classNameValue} shadow-tile ${modeClass}`;
                            tileElement.textContent = displayContent;

                            // X√≥a kh·ªèi map ƒë·ªÉ theo d√µi c√°c √¥ b·ªã x√≥a
                            existingTiles.delete(tileData.id);

                        } else {
                            // √î m·ªõi (v·ª´a ƒë∆∞·ª£c sinh ra ho·∫∑c l√† k·∫øt qu·∫£ c·ªßa m·ªôt merge)
                            const tile = document.createElement('div');
                            tile.id = tileData.id;
                            const classNameValue = tileData.value > 65536 ? 'super' : tileData.value;
                            
                            // √Åp d·ª•ng class 'tile-new' cho hi·ªáu ·ª©ng pop-in
                            tile.className = `tile tile-value-${classNameValue} shadow-tile tile-new ${modeClass}`;
                            tile.textContent = displayContent;
                            
                            // ƒê·∫∑t bi·∫øn CSS cho v·ªã tr√≠ transform v√† animation
                            tile.style.setProperty('--x', x);
                            tile.style.setProperty('--y', y);
                            
                            gameContainer.appendChild(tile);
                            
                            // FIX: X√≥a class 'tile-new' sau khi animation ho√†n t·∫•t
                            setTimeout(() => {
                                // ƒê·∫£m b·∫£o √¥ v·∫´n t·ªìn t·∫°i tr∆∞·ªõc khi thao t√°c
                                if (tile.parentElement) {
                                    tile.classList.remove('tile-new');
                                    // √Åp d·ª•ng l·∫°i transform cu·ªëi c√πng (scale 1)
                                    tile.style.transform = `translate(${x}, ${y})`;
                                }
                            }, ANIMATION_DURATION);
                        }
                    }
                }
            }
            
            // Lo·∫°i b·ªè c√°c √¥ kh√¥ng c√≤n tr√™n b·∫£ng (ƒë√£ b·ªã merge ho·∫∑c b·ªã ƒë·∫©y ra)
            existingTiles.forEach(tile => {
                // Th√™m m·ªôt ƒë·ªô tr·ªÖ nh·ªè ƒë·ªÉ √¥ merge/bi·∫øn m·∫•t kh√¥ng qu√° ƒë·ªôt ng·ªôt
                setTimeout(() => tile.remove(), ANIMATION_DURATION);
            });
        }


        // Core logic: Rotates the board to reuse the 'slide left' logic for all directions
        function rotateBoard(matrix) {
            const N = matrix.length;
            const newMatrix = Array.from({ length: N }, () => Array(N).fill(null)); // D√πng null
            for (let r = 0; r < N; r++) {
                for (let c = 0; c < N; c++) {
                    // Rotate 90 degrees clockwise
                    newMatrix[c][N - 1 - r] = matrix[r][c];
                }
            }
            return newMatrix;
        }

        // The core move function for sliding and merging tiles to the left
        function slideAndMergeLeft(row) {
            // L·ªçc ra c√°c √¥ c√≥ gi√° tr·ªã (kh√¥ng ph·∫£i null)
            let tiles = row.filter(val => val !== null);
            let newCells = [];
            let scoreIncrease = 0;

            for (let i = 0; i < tiles.length; i++) {
                let currentTile = tiles[i];

                if (i < tiles.length - 1 && currentTile.value === tiles[i + 1].value) {
                    // MERGE: currentTile doubles value, next tile is removed/destroyed
                    currentTile.value *= 2;
                    scoreIncrease += currentTile.value;
                    
                    // Push m·ªôt b·∫£n sao c·ªßa √¥ ƒë√£ ƒë∆∞·ª£c merge (c·∫ßn ID v√† Value)
                    // NOTE: Gi·ªØ nguy√™n ID c·ªßa √¥ ƒë·∫ßu ti√™n ƒë·ªÉ transition ho·∫°t ƒë·ªông
                    newCells.push({ ...currentTile }); 
                    i++; // B·ªè qua √¥ ƒë√£ ƒë∆∞·ª£c merge v√†o
                    
                    if (!hasWon && currentTile.value === 2048) {
                        hasWon = true;
                    }
                } else {
                    // NO MERGE
                    newCells.push(currentTile);
                }
            }

            // Ki·ªÉm tra xem c√≥ chuy·ªÉn ƒë·ªông/thay ƒë·ªïi n√†o x·∫£y ra kh√¥ng
            const oldValues = row.map(t => t ? t.value : 0).join('');
            const newValues = newCells.map(t => t ? t.value : 0).join('');
            // Ki·ªÉm tra c·∫£ s·ªë l∆∞·ª£ng √¥ ƒë√£ ƒë∆∞·ª£c n√©n/di chuy·ªÉn
            let moved = oldValues !== newValues || row.filter(t => t !== null).length !== newCells.length;

            // ƒê·ªám b·∫±ng null
            while (newCells.length < GRID_SIZE) {
                newCells.push(null);
            }
            
            return { newRow: newCells, scoreIncrease, moved };
        }

        // Main move handler
        function move(direction) {
            if (isGameOver || hasWon) return;

            let originalBoard = JSON.stringify(board);
            let hasMoved = false;

            // 0: Left, 1: Down, 2: Right, 3: Up (ƒê√£ s·ª≠a l·ªói h∆∞·ªõng di chuy·ªÉn)
            let rotations;
            if (direction === 'left') rotations = 0;
            else if (direction === 'down') rotations = 1; // 90 ƒë·ªô clockwise: Down -> Left
            else if (direction === 'right') rotations = 2;
            else if (direction === 'up') rotations = 3;   // 270 ƒë·ªô clockwise: Up -> Left

            // 1. √Åp d·ª•ng rotations ƒë·ªÉ ƒë∆∞a h∆∞·ªõng di chuy·ªÉn v·ªÅ 'Left'
            for (let i = 0; i < rotations; i++) {
                board = rotateBoard(board);
            }

            // 2. Th·ª±c hi·ªán slide-and-merge
            for (let r = 0; r < GRID_SIZE; r++) {
                const { newRow, scoreIncrease, moved } = slideAndMergeLeft(board[r]);
                board[r] = newRow;
                score += scoreIncrease;
                if (moved) hasMoved = true;
            }

            // 3. Quay ng∆∞·ª£c rotations ƒë·ªÉ kh√¥i ph·ª•c b·∫£ng v·ªÅ h∆∞·ªõng ban ƒë·∫ßu
            for (let i = 0; i < (GRID_SIZE - rotations) % GRID_SIZE; i++) {
                board = rotateBoard(board);
            }

            // 4. C·∫≠p nh·∫≠t tr·∫°ng th√°i
            if (hasMoved) {
                // √Åp d·ª•ng chuy·ªÉn ƒë·ªông ngay l·∫≠p t·ª©c
                updateTiles(); 
                
                // Th√™m √¥ ng·∫´u nhi√™n v√† ki·ªÉm tra tr·∫°ng th√°i sau khi chuy·ªÉn ƒë·ªông k·∫øt th√∫c
                setTimeout(() => {
                    addRandomTile();
                    updateScore(); 
                    updateTiles(); // C·∫≠p nh·∫≠t l·∫ßn cu·ªëi ƒë·ªÉ hi·ªÉn th·ªã √¥ m·ªõi
                    checkGameState();
                }, ANIMATION_DURATION);
                
            } else {
                 checkGameState();
            }
        }

        // Checks for win/game over conditions
        function checkGameState() {
            if (hasWon && !isGameOver) {
                isGameOver = true;
                // N·∫øu th·∫Øng, ki·ªÉm tra ƒëi·ªÉm cao nh·∫•t v√† hi·ªÉn th·ªã overlay ph√π h·ª£p
                if (!checkAndUpdateHighScoreOnGameOver()) {
                     showOverlay("B·∫°n ƒë√£ th·∫Øng!", "win");
                }
                return;
            }

            // Check if there are any moves possible (Game Over)
            if (getEmptyCells().length === 0) {
                if (!canMove()) {
                    isGameOver = true;
                    
                    // N·∫øu thua, ki·ªÉm tra ƒëi·ªÉm cao nh·∫•t v√† hi·ªÉn th·ªã overlay ph√π h·ª£p
                    if (!checkAndUpdateHighScoreOnGameOver()) {
                        showOverlay("Game over!", "lose");
                    }
                }
            }
        }
        
        // Checks if any merge or slide is possible
        function canMove() {
            // Check for empty cells
            if (getEmptyCells().length > 0) return true;

            // Check for horizontal merges
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE - 1; c++) {
                    if (board[r][c] && board[r][c+1] && board[r][c].value === board[r][c + 1].value) return true;
                }
            }

            // Check for vertical merges
            for (let c = 0; c < GRID_SIZE; c++) {
                for (let r = 0; r < GRID_SIZE - 1; r++) {
                    if (board[r][c] && board[r+1][c] && board[r][c].value === board[r + 1][c].value) return true;
                }
            }

            return false; // No empty cells and no possible moves/merges
        }


        // Shows the game over or win screen
        function showOverlay(message, type) {
            overlayMessage.textContent = message;
            
            // N·∫øu l√† k·ª∑ l·ª•c m·ªõi, d√πng m√†u v√†ng v√† n√∫t 'Th·ª≠ l·∫°i'
            const isHighScore = message.startsWith("K·ª∑ l·ª•c m·ªõi:");
            const btnClass = (type === 'win' || isHighScore) 
                ? 'bg-yellow-600 hover:bg-yellow-700' 
                : 'bg-[#8f7a66] hover:bg-[#9f8a75]';
                
            tryAgainBtn.className = `font-bold py-3 px-6 rounded-lg shadow-xl text-white text-lg transition-all ${btnClass}`;
            tryAgainBtn.textContent = (type === 'win' && !isHighScore) ? 'Ch∆°i ti·∫øp' : 'Th·ª≠ l·∫°i';
            
            overlay.classList.remove('hidden');
        }

        // --- Event Listeners ---
        
        // Game Mode Change Handler
        gameModeSelector.addEventListener('change', (e) => {
            gameMode = e.target.value;
            // B·∫Øt ƒë·∫ßu tr√≤ ch∆°i m·ªõi ngay l·∫≠p t·ª©c khi thay ƒë·ªïi ki·ªÉu ch∆°i
            setupGame(); 
        });


        // Keyboard input handler
        document.addEventListener('keydown', (e) => {
            if (isGameOver) return;
            switch (e.key) {
                case 'ArrowLeft':
                case 'a':
                    e.preventDefault();
                    move('left');
                    break;
                case 'ArrowRight':
                case 'd':
                    e.preventDefault();
                    move('right');
                    break;
                case 'ArrowUp':
                case 'w':
                    e.preventDefault();
                    move('up');
                    break;
                case 'ArrowDown':
                case 's':
                    e.preventDefault();
                    move('down');
                    break;
            }
        });

        // Touch input handler (for mobile swipe)
        let touchstartX = 0;
        let touchstartY = 0;
        let touchendX = 0;
        let touchendY = 0;
        const SWIPE_THRESHOLD = 50;

        gameContainer.addEventListener('touchstart', (e) => {
            if (isGameOver) return;
            touchstartX = e.changedTouches[0].screenX;
            touchstartY = e.changedTouches[0].screenY;
        }, false);

        gameContainer.addEventListener('touchend', (e) => {
            if (isGameOver) return;
            touchendX = e.changedTouches[0].screenX;
            touchendY = e.changedTouches[0].screenY;
            handleGesture();
        }, false);

        function handleGesture() {
            const dx = touchendX - touchstartX;
            const dy = touchendY - touchstartY;

            // Check if the distance is sufficient
            if (Math.abs(dx) < SWIPE_THRESHOLD && Math.abs(dy) < SWIPE_THRESHOLD) {
                return; // Not a swipe
            }

            if (Math.abs(dx) > Math.abs(dy)) {
                // Horizontal swipe
                if (dx > 0) move('right');
                else move('left');
            } else {
                // Vertical swipe
                if (dy > 0) move('down');
                else move('up');
            }
        }
        
        // --- N√∫t ƒëi·ªÅu khi·ªÉn b·∫±ng click ---
        // ƒê·∫£m b·∫£o c√°c n√∫t v·∫´n c√≥ listener m·∫∑c d√π ƒë√£ ·∫©n
        if (btnUp) btnUp.addEventListener('click', () => { move('up'); });
        if (btnLeft) btnLeft.addEventListener('click', () => { move('left'); });
        if (btnRight) btnRight.addEventListener('click', () => { move('right'); });
        if (btnDown) btnDown.addEventListener('click', () => { move('down'); });
        // --- End N√∫t ƒëi·ªÅu khi·ªÉn b·∫±ng click ---

        // Th√™m listener cho s·ª± ki·ªán resize ƒë·ªÉ ƒë·∫£m b·∫£o k√≠ch th∆∞·ªõc TILE_SIZE_PX ƒë∆∞·ª£c c·∫≠p nh·∫≠t khi thay ƒë·ªïi k√≠ch th∆∞·ªõc m√†n h√¨nh
        window.addEventListener('resize', updateTiles);


        // New Game Button
        newGameBtn.addEventListener('click', setupGame);
        tryAgainBtn.addEventListener('click', () => {
             // If player clicks 'Continue' after winning, just hide overlay and let them continue
            if (hasWon && isGameOver) {
                isGameOver = false; // Allow further moves
                overlay.classList.add('hidden');
                // The win flag (hasWon) remains true so they don't get the win message again
            } else {
                setupGame();
            }
        });

        // Initialize the game when the page loads
        window.onload = () => {
             loadHighScore(); // T·∫£i ƒëi·ªÉm cao nh·∫•t l·∫ßn ƒë·∫ßu
             setupGame(); 
        };

    </script>

</body>
</html>
